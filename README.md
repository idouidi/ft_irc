         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
         â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
         â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€
         â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Qu'est-ce-qu'IRC:
-----------------

IRC (Internet Relay Chat) est un protocole de communication en temps rÃ©el utilisÃ© principalement pour la discussion en groupe sur les rÃ©seaux. 
Il permet Ã©galement l'Ã©change de fichiers et la rÃ©alisation de transferts de fichiers entre utilisateurs. Il est souvent utilisÃ© pour des discussions en groupe, mais peut Ã©galement Ãªtre utilisÃ© pour des discussions en tÃªte-Ã -tÃªte.

Comment fonctionne IRC ?:
-----------------------

IRC fonctionne sur un modÃ¨le client-serveur, oÃ¹ les utilisateurs se connectent Ã  un serveur IRC et rejoignent des canaux de discussion

    Qu'est-ce-qu'un modele client-serveur ?
    ---------------------------------------

    Un modÃ¨le client-serveur est un modÃ¨le de communication informatique qui permet Ã  plusieurs programmes informatiques (clients) d'accÃ©der aux ressources ou aux services fournis par un autre programme informatique (serveur).
    Dans ce modÃ¨le, le serveur est un programme qui fournit un service ou une ressource Ã  d'autres programmes informatiques, les clients. Le serveur fonctionne en permanence, Ã  l'Ã©coute de requÃªtes Ã©mises par les clients.
    Le client est un programme qui demande un service ou une ressource au serveur en envoyant une requÃªte. Le client attend ensuite une rÃ©ponse du serveur avant de poursuivre son traitement.
    Le serveur peut gÃ©rer simultanÃ©ment plusieurs requÃªtes de clients en utilisant des threads ou des processus pour traiter chaque demande individuellement. Les clients peuvent Ã©galement Ãªtre situÃ©s sur des ordinateurs diffÃ©rents, communiquant avec le serveur via un rÃ©seau informatique.

Comment se presente le modele client-serveur d'IRC ?
----------------------------------------------------
Le serveur IRC agit comme un point central de communication, en gÃ©rant les connexions des clients et en assurant la distribution des messages entre les clients. Les clients IRC se connectent au serveur en utilisant un protocole standard, gÃ©nÃ©ralement TCP/IP, et s'authentifient en fournissant un nom d'utilisateur et un mot de passe.
Les canaux peuvent Ãªtre publics ou privÃ©s, et sont identifiÃ©s par un nom qui commence souvent:
  - (#) pour les canaux publics
  - (&) pour les canaux privÃ©s.
Lorsqu'un utilisateur envoie un message dans un canal, le serveur le diffuse Ã  tous les autres utilisateurs connectÃ©s au canal.


Pour implementer TCP/IP,  nous devons d'abord apprendre que sont les sockets ?
------------------------------------------------------------------------------
Une socket est le mÃ©canisme que les systÃ¨mes d'exploitation les plus courants fournissent pour permettre aux programmes d'accÃ©der au rÃ©seau. Il permet d'envoyer et de recevoir des messages entre des applications (processus non liÃ©s) sur diffÃ©rentes machines en rÃ©seau.
Le mÃ©canisme des sockets a Ã©tÃ© crÃ©Ã© pour Ãªtre indÃ©pendant de tout type de rÃ©seau spÃ©cifique. Cependant, IP est de loin le rÃ©seau le plus dominant et l'utilisation la plus populaire des sockets.
L'utilisation des sockets se fait en quelques Ã©tapes :
   - Cree la socket
   - Identifier la socket
   - Sur le serveur, attendre une connexion entrante
   - Envoyer et recevoir des messages
   - Fermer le socket.

   1) cree la socket
        Nous devons faire un appel a l'appelle system socket.

         #### int server_fd = socket(domain, type, protocol);
         
        - domain/address family :   Domaine de communication dans lequel le socket doit Ãªtre crÃ©Ã©.

        - type:   le type de service. Celui-ci est sÃ©lectionnÃ© en fonction des           propriÃ©tÃ©s requises par l'application : SOCK_STREAM (service de circuit virtuel), SOCK_DGRAM (service de datagramme), SOCK_RAW (service IP direct). VÃ©rifiez auprÃ¨s de votre domain si un service particulier est disponible.

        - protocol:  indiquer un protocole spÃ©cifique Ã  utiliser pour prendre en charge l'opÃ©ration des sockets. Ceci est utile dans les cas oÃ¹ certaines familles peuvent avoir plus d'un protocole pour supporter un type de service donnÃ©. La valeur de retour est un descripteur de fichier (un petit nombre entier).

        Pour les sockets TCP/IP, nous voulons spÃ©cifier la famille d'adresses IP (AF_INET) et le service de circuit virtuel (SOCK_STREAM). Comme il n'y a qu'une seule forme de service de circuit virtuel, il n'y a pas de variations du protocole, donc le dernier argument, protocole, est zÃ©ro. Notre code pour crÃ©er un socket TCP ressemble Ã  ceci :
        
        #####   #include <sys/socket.h>
        #####   if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
        #####   {
        #####       perror(â€œcannot create socketâ€); 
        #####       return 0; 
        #####   }

    2) Identifier la socket 
        Lorsque nous parlons d'identifier une socket, nous parlons d'attribuer une adresse de transport Ã  la socket (un numÃ©ro de port dans un rÃ©seau IP).

            Qu'est-ce-qu'une addresse de transport ?
                L'adresse de transport est dÃ©finie dans une structure d'adresse de socket. Les sockets ayant Ã©tÃ© conÃ§us pour fonctionner avec diffÃ©rents types d'interfaces de communication, l'interface est trÃ¨s gÃ©nÃ©rale. Au lieu d'accepter, par exemple, un numÃ©ro de port comme paramÃ¨tre, elle prend une structure sockaddr dont le format rÃ©el est dÃ©terminÃ© par la famille d'adresses (type de rÃ©seau) que vous utilisez. Par exemple, si vous utilisez des sockets de domaine UNIX, bind crÃ©e un fichier dans le systÃ¨me de fichiers.

        Dans les sockets, cette  opÃ©ration s'appelle "binding an address" et l'appel systÃ¨me bind est utilisÃ© pour cela:

        #### int bind(int socket, const struct sockaddr *address, socklen_t address_len);
        
        - socket: le socket que nous venons de creer avec l'appel system "socket"

        - struct sockaddr *address : La structure sockaddr est un conteneur gÃ©nÃ©rique qui permet simplement au systÃ¨me d'exploitation de lire les deux premiers octets qui identifient la famille d'adresses. La famille d'adresses dÃ©termine la variante de la structure sockaddr Ã  utiliser, qui contient des Ã©lÃ©ments utiles pour ce type de communication spÃ©cifique. Pour les rÃ©seaux IP, nous utilisons la struct sockaddr_in, qui est dÃ©finie dans l'en-tÃªte netinet/in.h. Cette structure dÃ©finit :

                #### struct sockaddr_in 
                #### { 
                ####     __uint8_t         sin_len; 
                ####     sa_family_t       sin_family; 
                ####     in_port_t         sin_port; 
                ####     struct in_addr    sin_addr; 
                ####     char              sin_zero[8]; 
                #### };

                Avant d'appeler bind, nous devons remplir cette structure. Les trois parties clÃ©s que nous devons dÃ©finir sont :
                    - sin_family: La famille d'adresses que nous avons utilisÃ©e lorsque nous avons configurÃ© le socket. Dans notre cas, c'est AF_INET.
                    
                    - sin_port:  Le numÃ©ro de port (l'adresse de transport). Vous pouvez attribuer explicitement une adresse de transport (port) ou laisser le systÃ¨me d'exploitation en attribuer une. Si vous Ãªtes un client et que vous ne recevrez pas de connexions entrantes, vous laisserez gÃ©nÃ©ralement le systÃ¨me d'exploitation choisir n'importe quel numÃ©ro de port disponible en spÃ©cifiant le port 0. Si vous Ãªtes un serveur, vous choisirez gÃ©nÃ©ralement un numÃ©ro spÃ©cifique puisque les clients auront besoin de connaÃ®tre un numÃ©ro de port pour se connecter.

                    - sin_addr: L'adresse de ce socket. Il s'agit simplement de l'adresse IP de votre machine. Avec l'IP, votre machine aura une adresse IP pour chaque interface rÃ©seau. Par exemple, si votre machine dispose de connexions Wi-Fi et Ethernet, elle aura deux adresses, une pour chaque interface. La plupart du temps, nous ne nous soucions pas de spÃ©cifier une interface spÃ©cifique et pouvons laisser le systÃ¨me d'exploitation utiliser ce qu'il veut. L'adresse spÃ©ciale pour cela est 0.0.0.0, dÃ©finie par la constante symbolique INADDR_ANY.
            
        - socklen_t address_len: Comme la structure d'adresse peut diffÃ©rer selon le type de transport utilisÃ©, le troisiÃ¨me paramÃ¨tre spÃ©cifie la longueur de cette structure. Il s'agit simplement de sizeof(struct sockaddr_in).

        le code pour bind une socket :
        
        ##### #include <sys/socket.h>
        ##### struct sockaddr_in address;
        ##### // ðŸ’¡ Astuce pour connaitre les ports disponible sur sa machine:
        ##### // "netstat -an | grep LISTEN | awk '{print $4}' | awk -F ":" '{print $NF}' | sort -n | uniq"
        ##### const int PORT = 8080; 
        ##### memset((char *)&address, 0, sizeof(address));
        ##### address.sin_family = AF_INET; 
        ##### address.sin_addr.s_addr = htonl(INADDR_ANY);  // htonl convert a long int to a network representation 
        ##### address.sin_port = htons(PORT);               // htons convert a short int to network representation
        ##### 
        ##### if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) 
        ##### {
        #####   perror(â€œbind failedâ€);
        #####   return (0);
        ##### }
    
    3) Sur le serveur, attendre une connexion entrante
        Avant qu'un client puisse se connecter Ã  un serveur, ce dernier doit disposer d'une socket prÃªt Ã  accepter les connexions. L'appel systÃ¨me listen indique Ã  une socket qu'il doit Ãªtre capable d'accepter les connexions entrantes :

        #### #include <sys/socket.h> 
        #### int listen(int socket, int backlog);

            - socket: la socket que nous avons creer

            - backlog: dÃ©finit le nombre maximum de connexions en attente qui peuvent Ãªtre mises en file d'attente avant que les connexions ne soient refusÃ©es.

        ðŸ’¡La socket d'origine qui a Ã©tÃ© configurÃ©e pour l'Ã©coute est utilisÃ©e uniquement pour accepter des connexions, et non pour Ã©changer des donnÃ©es. 
        Par dÃ©faut, les opÃ©rations de socket sont synchrones, ou bloquantes, et accept bloquera jusqu'Ã  ce qu'une connexion soit prÃ©sente dans la file d'attente.

        L'appel systÃ¨me accept saisit la premiÃ¨re demande de connexion dans la file d'attente des connexions en attente (configurÃ©e dans listen) et crÃ©e une nouvelle socket pour cette connexion.
        la syntax d'accept est :

        #### #include <sys/socket.h> 
        #### int accept(int socket, struct sockaddr *address, socklen_t *restrict address_len);

            - socket: c'est la socket qui a ete set pour accepter les connections avec listen

            - address : c'est la structure d'adresse qui est initialise avec l'adresse du client qui effectue la connexion. Cela nous permet d'examiner l'adresse et le numÃ©ro de port de la socket qui se connecte si nous le souhaitons.

            - address_len : la longueur de la structure d'adresse.

            le code pour listen et accept:
            
            #### #include <sys/socket.h>
            #### int pending_connection: 8;
            #### if (listen(server_fd, pending_connection) < 0)
            #### {
            ####    perror("Listen failed");
            ####    exit(EXIT_FAILLURE);        
            #### }
            #### if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))< 0 )
            #### {
            ####    perror("accept failed");
            ####    exit(EXIT_FAILLURE);        
            #### }
    
    4) Envoyer et recevoir des messages
        La communication est la partie facile. Les mÃªmes appels systÃ¨me de lecture et d'Ã©criture qui fonctionnent sur les fichiers fonctionnent Ã©galement sur les sockets.
        
        #### char buffer[1024] = {0};
        #### int valread = read( new_socket , buffer, 1024); 
        #### printf(â€œ%s\nâ€,buffer );
        #### if(valread < 0)
        #### { 
        ####     printf("No bytes are there to read");
        #### }
        ####
        #### char *hello = "Hello from the server";
        #### write(new_socket , hello , strlen(hello));
    
    5) Fermer le socket.
        Lorsque nous avons terminÃ© de communiquer, la chose la plus simple Ã  faire est de fermer une socket avec l'appel systÃ¨me close - la mÃªme close que celle utilisÃ©e pour les fichiers.